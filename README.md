# Interpretator
Ferzik+-
Запуск интерпретатора производится командой “interpret.exe <filename>” для запуска в обычном режиме и командой “interpret.exe <filename>  <something>” для запуска в режиме дебага, где filename – путь до файла с кодом интерпретируемой программы. В коде интерпретируемой программы запрещается использовать ключевые слова c/c++ и ключевые слова интерпретируемого языка в качестве имен переменных, функций, типов.
Общая инструкция по синтаксису интерпретируемого языка:
Переменные
Объявлять переменные можно с явным указанием значения и без. Сначала указывается тип переменной, потом имя переменной. Запрещается повторное использование одного имени для объявления переменных в рамках одной функции или одного глобального пространства, т.е. вне функций может быть одна переменная с “имя1” и при исполнении внутри функции может быть одна переменная c “имя1”. При этом каждый вызов функции рассматривается за новую область видимости, где может быть объявлена переменная с “имя1”.
Объявление переменной без инициализации выглядит как “<type> <name>;”, перечисление имен переменных через запятую, подобно синтаксису c++ нежелательно. 
Объявление переменной с инициализацией выглядит как “<type> <name> = <varName/Literal/arrayElement>”:
	double a = 4.6;
	int a = b[4];
	float g = r;
Для использования переменной, нужно писать её имя. Переменная ищется по имени в текущей области видимости (функции) и в глобальном сегменте.
При этом новой областью видимости не является блок if/while, при создании переменных в данных блоках нужно их вручную удалять командой “delete <varName>;”.
Типы данных
Доступны int, char, double, long_long (с нижним подчёркиванием), uchar, bool, string, float. После исполнения операций возвращаемый тип соответствует левому операнду, если не описано иного. Таким образом можно делать приведение типов:
	int perevod = 0;
	double t = 4;
Выражение perevod + t возвратит значение типа int, выражение t + perevod возвратит значение типа double. 
Операции присвоения между разными типами данных возможны, но при сужении типа, возможна потеря данных. Например, если char приравнять целое число int, которое больше типа char.
Нельзя ставить f после литерала для обозначения float, все литералы по умолчанию считаются либо long long либо double.
Нельзя делать последовательное присвоение a=b=c;
Управление памятью, массивы, ссылки
Есть возможность создавать многомерные массивы, размерность ограничена памятью и производительностью. Синтаксис следующий “<type> <arrayName>[arraySize];”, для создания многомерного массива достаточно приписать квадратные скобки с размерностью “<type> <arrayName>[arraySize1][arraySize2]…[arraySizeN];”. Объявление массива всегда происходит без инициализации, т. е. после закрывающейся квадратной скобки строка должна заканчиваться.
Обращение к элементу массива происходит ссылкой на относительную позицию в стеке. Используется индексация элементов, начинающаяся с 0. Пример выражений с обращением к массиву:
	int a = g[32] + fe[0] – t[6][2];
	de[3][6] = 1-4 + r[3];
При использовании имени массива без индексации, происходит работа с последним элементом в массиве. При использовании индексации к имени переменной происходит работа по ссылке, с точки зрения реализации производительность лучше не становится, поэтому лучше так к переменным не обращаться, так как делает код менее читабельным.
Вызов функций
При вызове функций обязательно указывается возвращаемый тип в треугольных скобках, интерпретатор ищет функцию по полному совпадению возвращаемого типа, имени функции и типам аргументов. Синтаксис вызова функции, треугольные скобки являются частью синтаксиса: “<returnType> funcName(arg1, arg2, …, arg n)”. При вызове функции необходимо куда-либо присваивать её значение. Пример:
	double res = <double>rongekutta(x1, x2, x3, x4) + <double>eiler(y1,x2);
Для передачи массивов и переменных по ссылкам в объявлении функции используются квадратные скобки с указанием относительного адреса начала памяти:
int meow(int cats[0], int dogs[0])…
Причем передавать надо схожим образом:
R = <int>meow(cats[0], dogs[0]);
Каждая функция обязана иметь return <any>, даже пустая. 
Подключение файлов и дополнительные функции
Есть возможность рекурсивно вставлять другие файлы с кодом, для этого внутри кода прописывается “# INSERT_FILE <относительный адрес подставляемого файла>;”. Файлы будут вставляться пока не выполняться INSERT_FILE из всех файлов.
Для повышения первичного функционала написаны дополнительные функции и переменные. В математическом модуле доступны cos, sin, решето Эратосфена, работа с векторами и двумерными матрицами, в алгоритмическом есть поразрядная сортировка типа int и перевод массива int размера n в массив uchar размером 4n.
Строки
Возможно использование строк как для хранения текста. Возможно присвоение string массиву char и наоборот, размер массива char постоянен.
char s[5];
s[0] = "eto pterodaktel\tpo imeni \'dinozavr\'";
string a = s[0]; 
теперь a = “eto p”.
Ввод/вывод
Вывод осуществляется “cout << outputData1 << outputData2 << .. << outputDataN << endl;”, можно выводить строки с экранированными символами, переменные, ключевой символ endl.
Ввод осуществляется “cin >> inpData1 >> inpData2 >>.. >> inpDataN >> endl;”

Циклы и ветвление
Для проверки условий доступна конструкция if-else:
if(условие)
{
	//code1
} 
else
{
	//code2
}
Можно упускать блок else:
if(условие)
{
	//code1
} 
Для создания циклов доступно только while:
while(условие)
{
    //code1
}
Блоки if и while можно вкладывать друг в друга. Нельзя создавать переменные внутри блоков, если очень хочется, то перед концом блока необходимо переменную удалить вручную командой delete.
